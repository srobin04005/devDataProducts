mean(mtcars$mpg + (1.96 * sd(mtcars$mpg)) / sqrt(length(mtcars -2)))
library(datasets); data(mtcars)
round(t.test(mtcars$mpg)$conf.int)
sd(mtcars$mpg)
mean(mtcars$mpg - (1.96 * sd(mtcars$mpg)) / sqrt(length(mtcars)))
mean(mtcars$mpg + (1.96 * sd(mtcars$mpg)) / sqrt(length(mtcars)))
library(datasets); data(mtcars)
round(t.test(mtcars$mpg)$conf.int)
mean(mtcars$mpg)
sd(mtcars$mpg)
mean(mtcars$mpg - (1.96 * sd(mtcars$mpg)) / sqrt(length(mtcars)))
mean(mtcars$mpg + (1.96 * sd(mtcars$mpg)) / sqrt(length(mtcars)))
library(datasets); data(mtcars)
round(t.test(mtcars$mpg)$conf.int)
mean(mtcars$mpg)
sd(mtcars$mpg)
(mean(mtcars$mpg - (1.96 * sd(mtcars$mpg))) / sqrt(length(mtcars)))
(mean(mtcars$mpg + (1.96 * sd(mtcars$mpg))) / sqrt(length(mtcars)))
#4. Evaluate the coverage of the confidence interval for 1/lambda: X¯±1.96Sn√.
ci.lower <- (xp - 1.96*std)/sqrt(length(xp))
ci.upper <- (xp + 1.96*std)/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower < 5]
ciu.bad <- ci.upper[ci.upper > 5]
#(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(xp, conf.level = 0.95)$conf.int
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1))
hist(xp, col="lightgrey",
xlim = c(3,7) )
abline(h=m, v=m)
abline(v= m- 1.96*std/sqrt(nosim), col="red")
abline(v= m+ 1.96*std/sqrt(nosim), col="red")
abline(v=mean(xp) + sd(xp)*1.96, col="brown")
abline(v=mean(xp) - sd(xp)*1.96, col="brown")
abline(v=mean(ci.lower), col="blue")
abline(v=mean(ci.upper), col="blue")
ci.l <- mean(xp) - 1.96 * std/sqrt(num);
ci.u <- mean(xp) + 1.96 * std/sqrt(num)
mean(xp)
nosim <- 40; lambda <- .2; num = 1000
# single sim
x.gen <- rexp(nosim, rate = lambda)
xp <- c() # vectors to hold means
for(i in 1:num){   # loop to create multiple simulation
x <- rexp(nosim, rate = lambda)
meaneach <- mean(x)
xp <- c(xp, meaneach)
}
percenttile(xp)
#4. Evaluate the coverage of the confidence interval for 1/lambda: X¯±1.96Sn√.
ci.lower <- (xp - 1.96*std)/sqrt(length(xp))
ci.upper <- (xp + 1.96*std)/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower < 5]
ciu.bad <- ci.upper[ci.upper > 5]
#(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(xp, conf.level = 0.95)$conf.int
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1))
hist(xp, col="lightgrey",
xlim = c(3,7) )
abline(h=m, v=m)
abline(v= m- 1.96*std/sqrt(nosim), col="red")
abline(v= m+ 1.96*std/sqrt(nosim), col="red")
abline(v=mean(xp) + sd(xp)*1.96, col="brown")
abline(v=mean(xp) - sd(xp)*1.96, col="brown")
abline(v=mean(ci.lower), col="blue")
abline(v=mean(ci.upper), col="blue")
ci.l <- mean(xp) - 1.96 * std/sqrt(num);
ci.u <- mean(xp) + 1.96 * std/sqrt(num)
mean(xp)
xp.mean <- mean(xp);
xp.sd <- sd(xp);
m <- 1/lambda;
std<- xp.sd
se <- std.error(xp)
v <- var(xp)
#c(xp.mean,xp.sd , std.error(xp))
par(mfrow=c(1,1))
#  fit curves
x.exp <- fitdistr(xp, "exponential")$estimate
x.est <- fitdistr(xp, "normal")$estimate
library(MASS)
require(graphics)
library(ggplot2)
library(plotrix)
nosim <- 40; lambda <- .2; num = 1000
# single sim
x.gen <- rexp(nosim, rate = lambda)
xp <- c() # vectors to hold means
for(i in 1:num){   # loop to create multiple simulation
x <- rexp(nosim, rate = lambda)
meaneach <- mean(x)
xp <- c(xp, meaneach)
}
percenttile(xp)
xp.mean <- mean(xp);
xp.sd <- sd(xp);
m <- 1/lambda;
std<- xp.sd
se <- std.error(xp)
v <- var(xp)
#c(xp.mean,xp.sd , std.error(xp))
par(mfrow=c(1,1))
#  fit curves
x.exp <- fitdistr(xp, "exponential")$estimate
x.est <- fitdistr(xp, "normal")$estimate
#4. Evaluate the coverage of the confidence interval for 1/lambda: X¯±1.96Sn√.
ci.lower <- (xp - 1.96*std)/sqrt(length(xp))
ci.upper <- (xp + 1.96*std)/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower < 5]
ciu.bad <- ci.upper[ci.upper > 5]
#(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(xp, conf.level = 0.95)$conf.int
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1))
hist(xp, col="lightgrey",
xlim = c(3,7) )
abline(h=m, v=m)
abline(v= m- 1.96*std/sqrt(nosim), col="red")
abline(v= m+ 1.96*std/sqrt(nosim), col="red")
abline(v=mean(xp) + sd(xp)*1.96, col="brown")
abline(v=mean(xp) - sd(xp)*1.96, col="brown")
abline(v=mean(ci.lower), col="blue")
abline(v=mean(ci.upper), col="blue")
ci.l <- mean(xp) - 1.96 * std/sqrt(num);
ci.u <- mean(xp) + 1.96 * std/sqrt(num)
mean(xp)
ci.lower
mean(ci.lower)
#4. Evaluate the coverage of the confidence interval for 1/lambda: X¯±1.96Sn√.
ci.lower <- xp - 1.96*std/sqrt(length(xp))
ci.upper <- xp + 1.96*std/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower < 5]
ciu.bad <- ci.upper[ci.upper > 5]
#(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(xp, conf.level = 0.95)$conf.int
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1))
hist(xp, col="lightgrey",
xlim = c(3,7) )
abline(h=m, v=m)
abline(v= m- 1.96*std/sqrt(nosim), col="red")
abline(v= m+ 1.96*std/sqrt(nosim), col="red")
abline(v=mean(xp) + sd(xp)*1.96, col="brown")
abline(v=mean(xp) - sd(xp)*1.96, col="brown")
abline(v=mean(ci.lower), col="blue")
abline(v=mean(ci.upper), col="blue")
ci.l <- mean(xp) - 1.96 * std/sqrt(num);
ci.u <- mean(xp) + 1.96 * std/sqrt(num)
mean(xp)
mean(ci.lower)
library(datasets); data(mtcars)
round(t.test(mtcars$mpg)$conf.int)
mean(mtcars$mpg)
sd(mtcars$mpg)
(mean(mtcars$mpg - (1.96 * sd(mtcars$mpg))) / sqrt(nrow(mtcars)))
(mean(mtcars$mpg + (1.96 * sd(mtcars$mpg))) / sqrt(nrow(mtcars)))
library(datasets); data(mtcars)
round(t.test(mtcars$mpg)$conf.int)
mean(mtcars$mpg)
sd(mtcars$mpg)
mean(mtcars$mpg) - 1.96 * sd(mtcars$mpg) / sqrt(nrow(mtcars))
mean(mtcars$mpg) + 1.96 * sd(mtcars$mpg) / sqrt(nrow(mtcars))
#4. Evaluate the coverage of the confidence interval for 1/lambda: X¯±1.96Sn√.
ci.lower <- xp - 1.96*std/sqrt(length(xp))
ci.upper <- xp + 1.96*std/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower < 5]
ciu.bad <- ci.upper[ci.upper > 5]
#(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(xp, conf.level = 0.95)$conf.int
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1))
hist(xp, col="lightgrey",
xlim = c(3,7) )
abline(h=m, v=m)
abline(v= m- 1.96*std/sqrt(nosim), col="red")
abline(v= m+ 1.96*std/sqrt(nosim), col="red")
abline(v=mean(xp) + sd(xp)*1.96, col="brown")
abline(v=mean(xp) - sd(xp)*1.96, col="brown")
abline(v=mean(ci.lower), col="blue")
abline(v=mean(ci.upper), col="blue")
ci.l <- mean(xp) - 1.96 * std/sqrt(num);
ci.u <- mean(xp) + 1.96 * std/sqrt(num)
ci.l
ci.u
tt
mean(xp)
#4. Evaluate the coverage of the confidence interval for 1/lambda: X¯±1.96Sn√.
ci.lower <- xp - 1.96*std/sqrt(length(xp))
ci.upper <- xp + 1.96*std/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower < 5]
ciu.bad <- ci.upper[ci.upper > 5]
#(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(x.gen, conf.level = 0.95)$conf.int
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1))
hist(xp, col="lightgrey",
xlim = c(3,7) )
abline(h=m, v=m)
abline(v= m- 1.96*std/sqrt(nosim), col="red")
abline(v= m+ 1.96*std/sqrt(nosim), col="red")
abline(v=mean(xp) + sd(xp)*1.96, col="brown")
abline(v=mean(xp) - sd(xp)*1.96, col="brown")
abline(v=mean(ci.lower), col="blue")
abline(v=mean(ci.upper), col="blue")
ci.l <- mean(xp) - 1.96 * std/sqrt(num);
ci.u <- mean(xp) + 1.96 * std/sqrt(num)
ci.l
ci.u
tt
mean(xp)
#4. Evaluate the coverage of the confidence interval for 1/lambda: X¯±1.96Sn√.
ci.lower <- xp - 1.96*std/sqrt(length(xp))
ci.upper <- xp + 1.96*std/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower < 5]
ciu.bad <- ci.upper[ci.upper > 5]
#(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(xp, conf.level = 0.95)$conf.int
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1))
hist(xp, col="lightgrey",
xlim = c(3,7) )
abline(h=m, v=m)
abline(v= m- 1.96*std/sqrt(nosim), col="red")
abline(v= m+ 1.96*std/sqrt(nosim), col="red")
abline(v=mean(xp) + sd(xp)*1.96, col="brown")
abline(v=mean(xp) - sd(xp)*1.96, col="brown")
abline(v=mean(ci.lower), col="blue")
abline(v=mean(ci.upper), col="blue")
ci.l <- mean(xp) - 1.96 * std/sqrt(num);
ci.u <- mean(xp) + 1.96 * std/sqrt(num)
ci.l
ci.u
tt
TT
mean(xp)
#4. Evaluate the coverage of the confidence interval for 1/lambda: X¯±1.96Sn√.
ci.lower <- xp - 1.96*std/sqrt(length(xp))
ci.upper <- xp + 1.96*std/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower < 5]
ciu.bad <- ci.upper[ci.upper > 5]
#(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(xp, conf.level = 0.95)
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1))
hist(xp, col="lightgrey",
xlim = c(3,7) )
abline(h=m, v=m)
abline(v= m- 1.96*std/sqrt(nosim), col="red")
abline(v= m+ 1.96*std/sqrt(nosim), col="red")
abline(v=mean(xp) + sd(xp)*1.96, col="brown")
abline(v=mean(xp) - sd(xp)*1.96, col="brown")
abline(v=mean(ci.lower), col="blue")
abline(v=mean(ci.upper), col="blue")
ci.l <- mean(xp) - 1.96 * std/sqrt(num);
ci.u <- mean(xp) + 1.96 * std/sqrt(num)
ci.l
ci.u
tt
TT
mean(xp)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
?pnorm
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
#4. Evaluate the coverage of the confidence interval for 1/lambda: X¯±1.96Sn???.
ci.lower <- xp - 1.96*std/sqrt(length(xp))
ci.upper <- xp + 1.96*std/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower > 5]
ciu.bad <- ci.upper[ci.upper < 5]
(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(xp, conf.level = 0.95)
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1))
hist(xp, col="lightgrey",
xlim = c(3,7) )
abline(h=m, v=m)
abline(v= m- 1.96*std/sqrt(nosim), col="red")
abline(v= m+ 1.96*std/sqrt(nosim), col="red")
abline(v=mean(xp) + sd(xp)*1.96, col="brown")
abline(v=mean(xp) - sd(xp)*1.96, col="brown")
abline(v=mean(ci.lower), col="blue")
abline(v=mean(ci.upper), col="blue")
ci.l <- mean(xp) - 1.96 * std/sqrt(num);
ci.u <- mean(xp) + 1.96 * std/sqrt(num)
ci.l
ci.u
tt
TT
mean(xp)
par(mfrow=c(1,1))
# 2. Show how variable it is and compare it to the theoretical variance of the distribution.
hist(xp,prob=TRUE, density=0, col="lightgrey",
main="",  xlab="fg. 4")
points(x=(mean(xp) + sd(xp)^2),y=0, col="blue")
points(x=(mean(xp) - sd(xp)^2),y=0, col="blue")
curve(dnorm(x,mean=xp.mean, sd=xp.sd), add=TRUE, col="blue")
points(x=(5+1),y=0, col="red")
points(x=(5-1),y=0, col="red")
curve(dnorm(x,mean=5,sd=1), add=TRUE, col="red")
?par
par(mar=c(2,2,2,2),mfrow=c(1,1))
# 2. Show how variable it is and compare it to the theoretical variance of the distribution.
hist(xp,prob=TRUE, density=0, col="lightgrey",
main="",  xlab="fg. 4")
points(x=(mean(xp) + sd(xp)^2),y=0, col="blue")
points(x=(mean(xp) - sd(xp)^2),y=0, col="blue")
curve(dnorm(x,mean=xp.mean, sd=xp.sd), add=TRUE, col="blue")
points(x=(5+1),y=0, col="red")
points(x=(5-1),y=0, col="red")
curve(dnorm(x,mean=5,sd=1), add=TRUE, col="red")
par(oma=c(1,1,1,1), mar=c(2,2,2,2),mfrow=c(1,1))
# 2. Show how variable it is and compare it to the theoretical variance of the distribution.
hist(xp,prob=TRUE, density=0, col="lightgrey",
main="",  xlab="fg. 4")
points(x=(mean(xp) + sd(xp)^2),y=0, col="blue")
points(x=(mean(xp) - sd(xp)^2),y=0, col="blue")
curve(dnorm(x,mean=xp.mean, sd=xp.sd), add=TRUE, col="blue")
points(x=(5+1),y=0, col="red")
points(x=(5-1),y=0, col="red")
curve(dnorm(x,mean=5,sd=1), add=TRUE, col="red")
ci.lower <- xp - 1.96*std/sqrt(length(xp))
ci.upper <- xp + 1.96*std/sqrt(length(xp))
#c(mean(ci.lower),mean(ci.upper))
cil.bad <- ci.lower[ci.lower > 5]
ciu.bad <- ci.upper[ci.upper < 5]
#(length(ciu.bad) + length(cil.bad))/num
tt <- t.test(xp, conf.level = 0.95)
TT <- (mean(xp) + c(-1, 1) * 1.96 * sd(xp)/sqrt(length(xp)))
par(mfrow=c(1,1) )
hist(xp, col="lightgrey",
xlim = c(3,7), main="Coverage of the Confidence Interval", xlab="Distribution" )
abline( v=m)
abline(v=mean(ci.lower), col="red")
abline(v=mean(ci.upper), col="red")
TT
load("~/R/data/statistical Inference/.RData")
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
datasets
datasets()
data()
?hflights
??hflights
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
data()
?hflights
install.packages("dplyr")
?hflights
??hflights
?hflights_df
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('C:/Users/srobin/Downloads/R/tutorial/plyr-tutorial/examples/bnames-cluster.r', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('C:/Users/srobin/Downloads/R/tutorial/plyr-tutorial/examples/bnames-explore.r', echo=TRUE)
View(bnames)
str(bnames)
source('~/.active-rstudio-document', echo=TRUE)
str(hflights)
source('~/.active-rstudio-document', echo=TRUE)
?dplyr
devtools::install_github("RSQLServer", "hs3180")
library("rJava", lib.loc="~/R/win-library/3.1")
devtools::install_github("RSQLServer", "hs3180")
install.packages("rJava")
devtools::install_github("RSQLServer", "hs3180")
devtools::install_github("dplyr.sqlserver", "hs3180")
devtools::install_github("RSQLServer", "hs3180")
source('C:/Users/srobin/Downloads/R/tutorial/plyr-tutorial/examples/baseball.r', echo=TRUE)
install.packages("segmented")
source('C:/Users/srobin/Downloads/R/tutorial/plyr-tutorial/examples/baseball.r', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
source('~/.active-rstudio-document', echo=TRUE)
mod <- lm(g ~ p, data = bruth)
segmented(mod, seg.Z = ~ p, psi = list(p = 0.5))
segmented(mod, seg.Z = ~ p, psi = list(p = c(0.3, 0.7)))
devtools::install_github("RSQLServer", "hs3180")
mod <- lm(g ~ p, data = bruth)
segmented(mod, seg.Z = ~ p, psi = list(p = 0.5))
segmented(mod, seg.Z = ~ p, psi = list(p = c(0.3, 0.7)))
mod <- lm(g ~ p, data = bruth)
segmented(mod, seg.Z = ~ p, psi = list(p = 0.5))
segmented(mod, seg.Z = ~ p, psi = list(p = c(0.3, 0.7)))
segmod <- dlply(b2, "id", function(df) {
df <- as.data.frame(df)
mod <- lm(g ~ p, data = df)
segmented(mod, seg.Z = ~ p, psi = list(p = 0.5))
})
segmod <- llply(linmod, )
head(b2)
# Now what sort of model should we use?
bruth <- subset(b2, id == "ruthba01")
qplot(career, g, data = bruth, geom = "line")
qplot(career, g, data = b2, geom="boxplot", group = round_any(career, 0.05))
# Could we model that as two straight lines?
bruth$p <- (bruth$career - 0.5) * 100
mod <- lm(g ~ p + p:I(p > 0), data = bruth)
bruth$ghat <- predict(mod)
qplot(career, g, data = bruth, geom = "line") +
geom_line(aes(y = ghat), colour = "red")
# It doesn't look great, but it's a start
# Let's fit that model to every player
b2$p <- (b2$career - 0.5) * 100
models <- dlply(b2, "id", lm, formula = g ~ p + p:I(p > 0))
# Or a bit more explicitly
models <- dlply(b2, "id", function(df) lm(g ~ p + p:I(p > 0), data = df))
length(models)
onem <- models[[1]]
onem
summary(onem)
coefs <- coef(onem)
names(coefs) <- c("mid", "inc", "dec")
rsq <- summary(onem)$r.squared
get_coefs <- function(model) {
coefs <- coef(model)
names(coefs) <- c("mid", "inc", "dec")
c(coefs, rsq = summary(model)$r.squared)
}
coefs <- ldply(models, get_coefs)
qplot(rsq, data = coefs, geom = "histogram", binwidth = 0.02)
qplot(mid, data = coefs, geom = "histogram", binwidth = 5)
qplot(inc, data = coefs, geom = "histogram", binwidth = 0.2)
qplot(dec, data = coefs, geom = "histogram", binwidth = 0.2)
qplot(rsq, inc, data=coefs)
qplot(dec, inc, data=coefs, colour=rsq)
# Maybe the problem is everyone doesn't peak in the middle of their careers
# Intead we could use a segmented regression
library(segmented)
mod <- lm(g ~ p, data = bruth)
segmented(mod, seg.Z = ~ p, psi = list(p = 0.5))
segmented(mod, seg.Z = ~ p, psi = list(p = c(0.3, 0.7)))
segmod <- dlply(b2, "id", function(df) {
df <- as.data.frame(df)
mod <- lm(g ~ p, data = df)
segmented(mod, seg.Z = ~ p, psi = list(p = 0.5))
})
segmod <- llply(linmod, )
source('C:/Users/srobin/Downloads/R/tutorial/plyr-tutorial/examples/bnames-explore.r', echo=TRUE)
setwd("C:\\Users\\srobin\\Documents\\GitHub\\devDataProducts")
shinyapps::showLogs()
shiny::runApp()
getwd()
shinyapps::deployApp()
shiny::runApp()
shinyapps::deployApp()
shiny::runApp()
shiny::runApp()
shinyapps::deployApp()
